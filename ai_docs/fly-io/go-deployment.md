---
source: https://fly.io/docs/languages-and-frameworks/golang/
fetched: 2025-08-21
version: latest
---

# Go Application Deployment on Fly.io

## Quick Start

### Prerequisites
- Go application with `go.mod` file
- flyctl installed and authenticated

### Basic Deployment
```bash
# 1. Navigate to your Go project
cd your-go-app

# 2. Launch (creates fly.toml and Dockerfile)
fly launch

# 3. Deploy
fly deploy
```

## Project Structure

### Required Files
```
your-go-app/
├── go.mod              # Required for Go detection
├── go.sum              # Dependencies
├── main.go             # Entry point
├── fly.toml            # Created by fly launch
└── Dockerfile          # Created by fly launch
```

### Generated fly.toml Example
```toml
app = "your-app-name"
primary_region = "sea"

[build]

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 0
  processes = ["app"]

[[vm]]
  memory = "1gb"
  cpu_kind = "shared"
  cpus = 1
```

## Go-Specific Configuration

### HTTP Server Setup
```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "os"
)

func main() {
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }

    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello from Fly.io!")
    })

    log.Printf("Server starting on port %s", port)
    log.Fatal(http.ListenAndServe(":"+port, nil))
}
```

### Environment Variables
- `PORT`: Set automatically by Fly.io (defaults to 8080)
- Access via `os.Getenv("PORT")`
- Set custom variables via `fly secrets set`

### Static Files with embed
```go
package main

import (
    "embed"
    "net/http"
)

//go:embed static/*
var staticFiles embed.FS

func main() {
    // Serve embedded static files
    http.Handle("/static/", http.FileServer(http.FS(staticFiles)))
    
    // Your other routes...
    http.ListenAndServe(":8080", nil)
}
```

## Dockerfile Customization

### Default Dockerfile Pattern
```dockerfile
# Generated by Fly.io
FROM golang:1.21-bookworm as builder

WORKDIR /usr/src/app
COPY go.mod go.sum ./
RUN go mod download && go mod verify
COPY . .
RUN go build -v -o app ./...

FROM debian:bookworm
RUN apt-get update && apt-get install -y ca-certificates
COPY --from=builder /usr/src/app/app /usr/local/bin/
CMD ["app"]
```

### Alpine Alternative (Smaller Size)
```dockerfile
FROM golang:1.21-alpine as builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o app

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/app .
CMD ["./app"]
```

## Common Deployment Patterns

### Web Application
```bash
# Standard web app deployment
fly launch --no-deploy     # Configure first
fly deploy                  # Deploy when ready
```

### API Service
```toml
# fly.toml for API service
[http_service]
  internal_port = 8080
  auto_stop_machines = "off"  # Keep running for API
  min_machines_running = 1
```

### Background Worker
```toml
# fly.toml for worker (no HTTP)
# Remove [http_service] section entirely

[[vm]]
  memory = "512mb"
  cpu_kind = "shared"
  cpus = 1
```

## Database Integration

### PostgreSQL with Fly
```bash
# Create Fly PostgreSQL
fly postgres create --name myapp-db

# Attach to your app
fly postgres attach myapp-db

# Connection string available as DATABASE_URL secret
```

### Database Connection in Go
```go
package main

import (
    "database/sql"
    "os"
    _ "github.com/lib/pq"
)

func main() {
    databaseURL := os.Getenv("DATABASE_URL")
    db, err := sql.Open("postgres", databaseURL)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // Your database logic...
}
```

## Production Optimizations

### Multi-Region Deployment
```bash
# Add regions for better performance
fly regions add lax ord iad

# Scale across regions
fly scale count 3
```

### Resource Optimization
```bash
# Adjust based on your needs
fly scale memory 512mb      # For lightweight apps
fly scale memory 2gb        # For memory-intensive apps
```

### Health Checks
```go
// Add health check endpoint
http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
})
```

### Graceful Shutdown
```go
package main

import (
    "context"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    server := &http.Server{Addr: ":8080"}
    
    // Start server in goroutine
    go func() {
        if err := server.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()

    // Wait for interrupt signal
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    // Graceful shutdown
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    server.Shutdown(ctx)
}
```

## Troubleshooting

### Common Issues
```bash
# Check deployment status
fly status

# View logs for errors
fly logs

# Access running container
fly ssh console

# Check machine details
fly machine list
```

### Build Failures
- Ensure `go.mod` is in project root
- Check Go version compatibility
- Verify all dependencies are available
- Use `fly deploy --build-only` to test builds

### Runtime Issues
- Check `PORT` environment variable usage
- Verify health check endpoints
- Monitor memory usage with `fly scale show`
- Check region-specific issues with `fly regions list`

## Best Practices

1. **Use embed for static files** instead of external file serving
2. **Set proper PORT handling** with environment variable fallback
3. **Implement health checks** for better monitoring
4. **Use secrets for sensitive data** instead of environment variables
5. **Test locally first** before deploying
6. **Monitor logs regularly** with `fly logs`
7. **Scale appropriately** based on actual usage
8. **Use multiple regions** for global applications